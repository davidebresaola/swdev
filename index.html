<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Software Development Methodologies</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            color: #fff;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 20px;
            text-align: center;
        }
        h1 {
            margin: 0;
        }
        .main {
            display: flex;
            flex: 1;
            background-color: #000;
            background-image: url('img/cat.jpg');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: left;
            background-attachment: fixed;
        }
        .index {
            position: sticky;
            top: 0;
            padding: 20px;
            background-color: #f4f4f4;
            width: 250px;
            height: 100vh;
            overflow-y: auto;
            box-sizing: border-box;
            color: #000;
        }
        .index ul {
            list-style: none;
            padding: 0;
        }
        .index li {
            margin-bottom: 10px;
        }
        .index a {
            text-decoration: none;
            color: #000;
        }
        .index a:visited {
            color: #000;
        }
        .container {
            display: flex;
            flex: 1;
            max-width: 800px;
            margin: 0 auto;
            padding: 0 20px;
            box-sizing: border-box;
        }
        .content {
            flex: 3;
            padding-top: 0;
        }
        .chapter {
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 20px;
            padding: 20px;
            box-sizing: border-box;
        }
        .chapter h2 {
            margin-top: 0;
        }
        .chapter p {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Software Development Methodologies</h1>
    </header>
    <div class="main">
        <div class="index" id="index">
            <h2>Chapter Index</h2>
            <ul></ul>
        </div>
        <div class="container">
            <div class="content">
                <div class="chapter" id="memory">
                    <h2>Java Memory Management</h2>
                    <p><strong>JVM (Java Virtual Machine):</strong></p>
                    <ul>
                        <li><strong>ClassLoader:</strong>
                            <ul>
                                <li>Loading: Generate binary data from .class
                                    bytecode and save in the method area.</li>
                                <li>Linking: Correctness verification and
                                    allocate
                                    memory for static variables.</li>
                                <li>Initialization: Assign values to static
                                    variables.</li>
                            </ul>
                        </li>
                        <li><strong>Execution engine:</strong> Executes
                            bytecode.</li>
                        <li><strong>Interpreter:</strong> Interprets bytecode
                            line
                            by line and executes. Disadvantage: Interpretation
                            every
                            time a method is called.</li>
                        <li><strong>Just-In-Time Compiler:</strong> Compiles the
                            entire bytecode, no re-interpretation of repeated
                            method
                            calls.</li>
                        <li><strong>Garbage collector:</strong> Destroys
                            unreferenced objects.</li>
                        <li><strong>Java Native Interface:</strong> Provides the
                            native libraries.</li>
                    </ul>
                    <p><strong>Memory:</strong></p>
                    <ul>
                        <li><strong>Method area:</strong> Class-level
                            information
                            (name, parent class name, methods and variables
                            info,
                            static variables). Only one and shared.</li>
                        <li><strong>Heap area:</strong> Information of all
                            objects.
                            Only one and shared resource.</li>
                        <li><strong>Stack area:</strong> Stores one run-time
                            stack
                            for every thread. Every frame of the stack stores
                            method
                            calls, destroyed and not shared.</li>
                        <li><strong>PC Registers:</strong> Store address of
                            current
                            instruction of a thread.</li>
                        <li><strong>Native method stacks:</strong> Store native
                            method info for every thread.</li>
                    </ul>
                    <p><strong>Run-Time Memory Areas:</strong></p>
                    <ul>
                        <li><strong>Static area:</strong> Fixed size and
                            content.</li>
                        <li><strong>Run-time stack:</strong> Variable size and
                            content, function call and return.</li>
                        <li><strong>Heap:</strong> Fixed size, variable content,
                            dynamically allocated objects and data structures.
                            Each
                            memory word in the heap has 3 states: unused,
                            undefined,
                            or value. Function new(k) allocates a block of heap
                            space and returns the address of the next block of k
                            unused words available.</li>
                    </ul>
                    <p><strong>Common Issues:</strong></p>
                    <ul>
                        <li><strong>Stack overflow:</strong> When the top of a
                            stack
                            exceeds its fixed limit.</li>
                        <li><strong>Heap overflow:</strong> When the heap does
                            not
                            have enough blocks available to satisfy a call to
                            new.</li>
                    </ul>
                </div>
                <div class="chapter" id="types">
                    <h2>Java Types in Memory</h2>
                    <p><strong>Primitive:</strong> Unique dimension</p>
                    <p><strong>Class types:</strong></p>
                    <ul>
                        <li>Objects are stored in the heap.</li>
                        <li>Instance variables (or fields or attributes) -
                            Stored
                            within objects in the heap.</li>
                        <li>Local Variables (in methods) - Stored in the Stack,
                            destroyed at the end of the block.</li>
                        <li>Static Variables - Only one copy is stored in static
                            memory.</li>
                    </ul>
                    <p><strong>Array:</strong> An array is an object stored in
                        the
                        heap. Declaration allocates memory space for a
                        reference,
                        default is null.</p>
                    <p><strong>Creation:</strong> <code>int[] a = new
                            int[10];</code> <code>int[] primes =
                            {2,3,5,7,11,13};</code></p>
                    <p><strong>Access:</strong> <code>for (int i=0; i <
                            a.length;
                            i++) a[i] = i;</code></p>
                    <p><strong>Multidimensional:</strong> <code>String[][] table
                            =
                            new String[2][3];</code> <code>table[0][2] = new
                            String(“Mary”);</code></p>
                    <p><strong>String:</strong> "<code>ciao</code>" <> <code>new
                            String("ciao")</code></p>
                </div>
                <div class="chapter" id="gc">
                    <h2>Garbage Collection</h2>
                    <p>Garbage Collection is the process of removing unused
                        objects
                        from the heap space. It involves two main steps:</p>
                    <ol>
                        <li><strong>Mark:</strong> Identifies which pieces of
                            memory
                            are in use and which aren't.</li>
                        <li><strong>Sweep:</strong> Removes objects identified
                            during the “mark” phase.</li>
                    </ol>
                    <p>Garbage can occur when:</p>
                    <ul>
                        <li>An allocated block of heap memory has no reference
                            to it
                            (an “orphan”) (memory leak)</li>
                        <li>A reference exists to a block of memory that is no
                            longer allocated (a “widow”) (dangling
                            reference).</li>
                    </ul>
                    <p><code>System.gc()</code> can be used to force garbage
                        collection.</p>
                    <p>There are different algorithms for garbage
                        collection:</p>
                    <ul>
                        <li><strong>Reference counting:</strong> Gives each
                            object a
                            counter of references. When it becomes 0, it is
                            considered garbage. However, not all garbage is
                            collected, especially in circular chains.</li>
                        <li><strong>Mark and Sweep:</strong> Sets a Mark Bit to
                            1
                            for reachable objects and clears objects with the
                            Mark
                            Bit set to 0.</li>
                        <li><strong>Copy Collection:</strong> Faster than
                            mark-sweep
                            as it requires only one pass, but it reduces the
                            size of
                            the heap space.</li>
                    </ul>
                    <p>Garbage Collection implementations include:</p>
                    <ul>
                        <li><strong>Serial Garbage Collector:</strong> Freezes
                            all
                            application threads when it runs.</li>
                        <li><strong>Parallel Garbage Collector:</strong> Default
                            option, uses multiple threads for managing heap
                            space.</li>
                        <li><strong>CMS Garbage Collector:</strong> Concurrent
                            Mark
                            Sweep (deprecated).</li>
                        <li><strong>G1 Garbage Collector:</strong> Designed for
                            multiprocessor machines with large memory
                            space.</li>
                        <li><strong>Z Garbage Collector:</strong> Performs all
                            expensive work concurrently, without stopping the
                            execution of application threads.</li>
                    </ul>
                </div>
                <div class="chapter" id="threads">
                    <h2>Threads</h2>
                    <p><strong>Concurrency:</strong> Many processes share one
                        CPU.</p>
                    <p><strong>Parallelism:</strong> Processes are allocated to
                        parallel CPUs.</p>
                    <p>Threads (aka lightweight process or execution context)
                        are
                        subprocesses within a single program/process run in a
                        shared
                        memory space. Processes run in private separate memory
                        spaces.</p>
                    <h3>Multithreading:</h3>
                    <p><strong>Cooperative threads:</strong> Run without
                        interruption (problem of Starvation and
                        non-responsiveness).</p>
                    <p><strong>Preemptive threads:</strong> Can be switched.</p>
                    <h3>JVM Threads:</h3>
                    <p>JVM operates like a mini-OS and schedules its own threads
                        regardless of the underlying OS. The
                        <code>start()</code>
                        method can be called on a Thread object only once
                        (otherwise
                        RuntimeException).</p>
                    <p><strong>Deadlock Problem:</strong> Progress of a system
                        is
                        halted as each process is waiting to acquire a resource
                        held
                        by some other process (circular wait).</p>
                    <h3>Java Thread States:</h3>
                    <ul>
                        <li><strong>Running:</strong> When thread scheduler
                            selects
                            it.</li>
                        <li><strong>Runnable:</strong> Queued & eligible to run,
                            after the <code>start()</code> method.</li>
                        <li><strong>Blocked:</strong> NOT eligible to run or
                            waiting
                            for a resource.</li>
                        <li><strong>Sleeping:</strong> During
                            <code>Thread.sleep(ms)</code> time.</li>
                        <li><strong>Waiting:</strong> For thread interaction
                            (comes
                            back Runnable when another thread sends
                            notification).</li>
                    </ul>
                    <p><code>join()</code> method lets one thread "join onto the
                        end” of another thread (<code>t.join(5000);</code>).
                        Current
                        thread moves to Waiting state and becomes Runnable when
                        thread <code>t</code> is dead.</p>
                    <h3>Thread Priorities:</h3>
                    <p>A priority number (1-10) is assigned to each thread.</p>
                    <h3>JVM Scheduling Policy:</h3>
                    <ul>
                        <li><strong>Non-preemptive:</strong> Current thread is
                            executed until the end.</li>
                        <li><strong>Preemptive time-slicing:</strong> Thread is
                            executed until its time-slice is over.</li>
                    </ul>
                    <p><strong>High priority threads:</strong></p>
                    <ul>
                        <li>Are executed more often, or have longer
                            time-slice.</li>
                        <li>Stop execution of lower-priority threads before
                            their
                            time-slice is over.</li>
                    </ul>
                    <p><code>t.setPriority(8);</code></p>
                    <p><code>t.yield()</code> makes the currently running thread
                        go
                        back to Runnable state and allows other threads of the
                        same
                        priority (but also the thread <code>t</code>) to
                        run.</p>
                    <p><code>t.sleep()</code> and <code>t.yield()</code> affect
                        the
                        thread in execution (they are static methods).</p>
                </div>
                <div class="chapter" id="synchronization">
                    <h2>Thread Synchronization</h2>
                    <p><strong>Race Condition:</strong> Occurs when many threads
                        can
                        access the same resource simultaneously, potentially
                        leading
                        to corrupted data.</p>
                    <p>The <code>synchronized</code> modifier locks a code
                        block,
                        allowing only one thread to access it at a time. It
                        ensures
                        thread safety.</p>
                    <p>A sleeping thread doesn't release locks it holds, which
                        can
                        lead to deadlocks.</p>
                    <p><code>void wait()</code> Causes the current thread to
                        wait
                        until another thread invokes the <code>notify()</code>
                        or
                        <code>notifyAll()</code> method for the same object.</p>
                    <p>In a signaled object lock, the thread keeps executing,
                        while
                        in a non-signaled object lock, the thread is
                        suspended.</p>
                    <p><code>void notify()</code> Wakes up a single thread that
                        is
                        waiting on the lock of the current object.</p>
                    <p><code>void notifyAll()</code> Wakes up all threads that
                        are
                        waiting on the lock of the current object.</p>
                    <p><strong>Livelock:</strong> Occurs when threads are
                        actively
                        running, but no progress is made due to continuous
                        response
                        to each other's actions.</p>
                    <p><strong>Thread Starvation:</strong> Happens when some
                        threads
                        make progress while others aren't executing, often due
                        to
                        resource contention or priority inversion.</p>
                    <p><strong>Fork/Join Concurrency:</strong> Involves
                        splitting
                        tasks into smaller subtasks and executing them
                        concurrently.
                        Data is shared before forking and after joining.</p>
                </div>
                <div class="chapter" id="sockets">
                    <h2>Sockets</h2>
                    <p>Java Sockets provide an interface through which processes
                        can
                        send and receive information.</p>
                    <p>A socket is defined by an IP address and a port
                        number.</p>
                    <p>A connection is identified by the source and destination
                        socket pair.</p>
                    <p>There are different types of sockets:</p>
                    <ul>
                        <li><strong>STREAM:</strong> Uses TCP for reliable
                            communication.</li>
                        <li><strong>DATAGRAM:</strong> Uses UDP for unreliable
                            communication.</li>
                        <li><strong>RAW:</strong> Allows direct data transfer
                            over
                            the IP protocol.</li>
                    </ul>
                    <p>The <code>DataInputStream</code> class is used to create
                        an
                        input stream to receive responses, while
                        <code>DataOutputStream</code> is used to send
                        information.</p>
                    <p>For server-side communication, multiple threads are
                        required
                        to allow communication with clients and listening for
                        new
                        connections to occur simultaneously.</p>
                    <p>The <code>accept()</code> method listens (blocks) for a
                        connection and then creates and returns a new Socket for
                        communication. The <code>close()</code> method is used
                        to
                        close the ServerSocket.</p>
                    <p>A servant thread is responsible for managing each client
                        connection socket, avoiding blocking the server with
                        only
                        one client. On the client side, a receiver thread
                        listens to
                        incoming messages without blocking the main
                        application.</p>
                </div>
                <div class="chapter" id="gui">
                    <h2>Java GUI</h2>
                    <p>The Java GUI (Graphical User Interface) follows the
                        Model-View-Controller (MVC) architecture:</p>
                    <ul>
                        <li><strong>Model:</strong> Application logic separated
                            from
                            the user interface.</li>
                        <li><strong>View:</strong> Places graphical elements
                            (visual
                            aspect).</li>
                        <li><strong>Controller:</strong> Associates behavior to
                            elements events.</li>
                    </ul>
                    <p>Important Java GUI components and their usage:</p>
                    <ul>
                        <li><strong>JFrame:</strong>
                            <ul>
                                <li>Base class for creating a window.</li>
                                <li>By default, closing the window doesn't
                                    terminate
                                    the application. Use
                                    <code>setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</code>
                                    to terminate the application on close.</li>
                            </ul>
                        </li>
                        <li><strong>JButton(String text):</strong> A button
                            component that can hold text.</li>
                        <li><strong>JLabel(String text, int alignment):</strong>
                            A
                            label with text and alignment options
                            (SwingConstants.LEFT, RIGHT, CENTER).</li>
                        <li><strong>JTextField(String text, int size):</strong>
                            A
                            single-line text field.</li>
                        <li><strong>JTextArea(String text, int rows, int
                                columns):</strong> A multi-line text area. Use
                            <code>setLineWrap(boolean)</code> and
                            <code>setWrapStyleWord(boolean)</code> for
                            wrapping.</li>
                        <li><strong>JScrollPane(Component component):</strong>
                            Adds
                            scroll bars to a component.</li>
                        <li><strong>JList(Object[] data):</strong> Displays a
                            list
                            of items.</li>
                        <li><strong>JCheckBox(String text, boolean
                                selected):</strong> A checkbox component.</li>
                        <li><strong>JRadioButton(String text, boolean
                                selected):</strong> A radio button
                            component.</li>
                        <li><strong>ButtonGroup:</strong> Ensures mutual
                            exclusion
                            for a group of radio buttons or checkboxes.</li>
                        <li><strong>JOptionPane:</strong> Provides standard
                            dialog
                            boxes:
                            <ul>
                                <li><code>JOptionPane.showMessageDialog(frame,
                                        "Message");</code> to show a message
                                    dialog.</li>
                                <li><code>JOptionPane.showOptionDialog</code>
                                    for
                                    choices.</li>
                                <li><code>JOptionPane.showInputDialog</code> to
                                    prompt for user input.</li>
                            </ul>
                        </li>
                    </ul>
                    <p>Layout Managers:</p>
                    <ul>
                        <li><strong>FlowLayout:</strong> Arranges components
                            from
                            left to right.</li>
                        <li><strong>GridLayout(int rows, int cols):</strong>
                            Arranges components in a grid.</li>
                        <li><strong>BorderLayout:</strong> Divides the container
                            into five regions: NORTH, SOUTH, EAST, WEST, and
                            CENTER.</li>
                        <li><strong>GridBagLayout:</strong> A flexible layout
                            manager that aligns components vertically and
                            horizontally, using a GridBagConstraints
                            object.</li>
                    </ul>
                    <p>Event Handling:</p>
                    <ul>
                        <li>Common events: MouseEvent, KeyEvent, ActionEvent,
                            AdjustmentEvent (scroll bars), FocusEvent,
                            ItemEvent,
                            MouseMotionEvent, WindowEvent.</li>
                        <li>Example: <code>aButton.addActionListener(e ->
                                doClick(),
                                this);</code></li>
                    </ul>
                    <p>Listener Interfaces:</p>
                    <ul>
                        <li><strong>ActionListener:</strong> Override
                            <code>actionPerformed</code> method.</li>
                        <li><strong>FocusListener:</strong> Methods:
                            <code>focusGained</code>,
                            <code>focusLost</code>.</li>
                        <li><strong>ItemListener:</strong> Method:
                            <code>itemStateChanged</code>.</li>
                        <li><strong>MouseListener:</strong> Methods:
                            <code>mouseClicked</code>,
                            <code>mouseEntered</code>,
                            <code>mouseExited</code>, <code>mousePressed</code>,
                            <code>mouseReleased</code>.</li>
                        <li><strong>MouseMotionListener:</strong> Methods:
                            <code>mouseDragged</code>,
                            <code>mouseMoved</code>.</li>
                        <li><strong>KeyListener:</strong> Methods:
                            <code>keyPressed</code>, <code>keyReleased</code>,
                            <code>keyTyped</code>.</li>
                        <li><strong>WindowListener:</strong> Handles window
                            events.</li>
                    </ul>
                    <p>Direct Drawing:</p>
                    <ul>
                        <li>Requires a callback method: <code>void
                                paint(Graphics
                                g)</code> provides methods to draw.</li>
                        <li>Use <code>repaint()</code> to invoke
                            <code>paint()</code> and update the view when
                            something
                            changes.</li>
                    </ul>
                </div>
                <div class="chapter" id="streams">
                    <h2>Streams</h2>
                    <p>TODO</p>

                </div>
                <div class="chapter" id="reflection">
                    <h2>Reflection</h2>
                    <p>Java Reflection is the process by which a program can
                        modify
                        its behavior at runtime. A program is reflective if it
                        can
                        analyze and modify its own parameters dynamically.</p>
                    <p><code>java.lang.Class</code>: This class provides methods
                        to
                        get the class of an object.</p>
                    <pre><code>// Get the class of an existing object
            Class&lt;?&gt; c = scan.getClass(); 
            
            // When only the type is known
            (AnyType).class;
            
            // Get the class by name
            Class&lt;?&gt; c1 = Class.forName("java.util.Scanner");
                </code></pre>
                    <p><code>java.lang.reflect.Constructor</code>: Represents a
                        constructor for a class object.</p>
                    <p><code>java.lang.reflect.Method</code>: Represents a
                        method in
                        a class.</p>
                    <p><code>java.lang.reflect.Field</code>: Represents a field
                        within a class.</p>
                    <p><code>java.lang.reflect.AccessibleObject</code>: This
                        class
                        is used to modify accessibility at runtime.</p>
                    <p><code>java.lang.reflect.Modifier</code>: Provides methods
                        to
                        extract facts about modifiers. For example,
                        <code>isPrivate(int i)</code> checks if the modifier is
                        private.</p>
                    <p>Function Pointers: In Java, function pointers are
                        emulated by
                        passing method objects and invoking them.</p>
                    <p><code>ClassLoader</code>: This class is responsible for
                        loading classes. Every class has a reference to the
                        ClassLoader that created it (except primitives).</p>
                    <p><strong>Bootstrap Class Loader:</strong> This is the
                        original
                        ClassLoader that has no parent class loader.</p>
                </div>
                <div class="chapter" id="verification-validation">
                    <h2>Verification and Validation</h2>
                    <p>Verification and Validation (V&V) are essential processes
                        in
                        software engineering to ensure the correctness and
                        quality
                        of software products.</p>
                    <h3>Differences</h3>
                    <table>
                        <tr>
                            <th>Aspect</th>
                            <th>Verification</th>
                            <th>Validation</th>
                        </tr><tr>
                            <td>Question</td>
                            <td>"Are we building the product right?"</td>
                            <td>"Are we building the right product?"</td>
                        </tr>
                        <tr>
                            <td>Objective</td>
                            <td>Evaluating whether the software is built
                                correctly
                                according to specifications.</td>
                            <td>Evaluating whether the right product is built to
                                meet user needs and expectations.</td>
                        </tr>
                        <tr>
                            <td>Focus</td>
                            <td>Process-oriented (internal quality)</td>
                            <td>Product-oriented (external quality)</td>
                        </tr>
                        <tr>
                            <td>Timing</td>
                            <td>Performed throughout the development
                                lifecycle.</td>
                            <td>Performed at the end of the development
                                lifecycle.</td>
                        </tr>
                        <tr>
                            <td>Method</td>
                            <td>Static analysis techniques, reviews, and
                                inspections.</td>
                            <td>Dynamic testing techniques, including various
                                types
                                of testing.</td>
                        </tr>
                    </table>
                    <h3>Techniques:</h3>
                    <img src="img/v&v_techniques.png"
                        alt="Verification and Validation Techniques"
                        style="max-width: 100%; height: auto;">
                    <h3>Terminology:</h3>
                    <ul>
                        <li><strong>Fault:</strong> A feature that may lead to
                            an
                            error due to a defect or incorrect requirement.</li>
                        <li><strong>Error:</strong> The runtime effect of
                            executing
                            a fault, which may result in a failure.</li>
                        <li><strong>Failure:</strong> The manifestation of an
                            error
                            external to the program.</li>
                    </ul>
                    <p>The longer the delay in detecting and removing defects,
                        the
                        higher the cost incurred.</p>
                    <h3>Goals of V&V:</h3>
                    <ul>
                        <li>Minimize the number of defects inserted during
                            software
                            development.</li>
                        <li>Maximize the number of defects discovered and
                            removed
                            during testing.</li>
                        <li>Minimize detection delay to promptly address
                            issues.</li>
                    </ul>
                    <h3>Static Analysis:</h3>
                    <p>Static analysis involves examining software artifacts
                        without
                        executing them. It helps identify potential issues early
                        in
                        the development process.</p>
                    <ul>
                        <li><strong>Automatic Code Analysis:</strong> This is
                            performed on the source code at compile time,
                            providing
                            insights into code quality and potential
                            vulnerabilities.</li>
                        <li><strong>Code Smells:</strong> Indications in the
                            code
                            that usually correspond to a problem, such as
                            violations
                            of design principles.</li>
                        <li><strong>Technical Debt:</strong> Refers to the
                            implied
                            cost of additional rework caused by choosing an
                            expedient solution rather than the best one, leading
                            to
                            the need for code rewriting.</li>
                    </ul>
                </div>
                <div class="chapter" id="testing">
                    <h2>Testing</h2>
                    <p>Testing is conducted to find defects and detect
                        differences
                        between actual and expected behavior.</p>
                    <h3>Why Testing?</h3>
                    <p>Testing is essential to:</p>
                    <ul>
                        <li>Improve software design.</li>
                        <li>Make software easier to understand.</li>
                        <li>Reduce debugging time.</li>
                        <li>Catch integration errors to produce better
                            code.</li>
                    </ul>
                    <h3>What to Test?</h3>
                    <p>Testing covers various aspects including:</p>
                    <ul>
                        <li>Boundary conditions.</li>
                        <li>Success and failure scenarios.</li>
                        <li>General functionality.</li>
                    </ul>
                    <h3>Test Case</h3>
                    <p>A test case is represented as:</p>
                    <p><strong>T1:</strong> (input1, input2, ...; expected
                        output)
                        // Name</p>
                    <h3>Test Suite</h3>
                    <p>A test suite is a collection of test cases:</p>
                    <p><strong>TS1:</strong> {T1, T2}</p>
                    <h3>Oracle</h3>
                    <p>An oracle is used to know the expected behavior for a
                        given
                        test case.</p>
                    <h3>Unit Test</h3>
                    <p>Unit testing can be performed in two ways:</p>
                    <ul>
                        <li><strong>Black Box:</strong> No knowledge of internal
                            structure, focusing on functional testing, involving
                            random testing, equivalence class partitioning, and
                            boundary conditions.</li>
                        <li><strong>White Box:</strong> Structural testing,
                            examining the internal structure, and covering
                            structural elements such as statements, decisions,
                            conditions, paths, and loops.</li>
                    </ul>
                    <h3>Integration Testing</h3>
                    <p>Integration testing involves adding one unit at a time to
                        test the system.</p>
                    <h3>Regression Test</h3>
                    <p>Regression testing involves testing the old code to
                        verify it
                        works after changes.</p>
                </div>
                <div class="chapter" id="black-box-testing">
                    <h2>Black Box Testing Overview</h2>

                    <p><strong>Black Box Tests</strong> focus on software
                        simplicity, making assumptions about implementation and
                        testing component interactions. They target interfaces
                        and
                        behavior.</p>

                    <h3>Selection Criteria:</h3>
                    <ul>
                        <li>Equivalence class-based</li>
                        <li>Boundary condition-based</li>
                    </ul>

                    <h3>Termination Criteria:</h3>
                    <ul>
                        <li>One test per equivalence class/boundary
                            condition</li>
                        <li>More than one test per equivalence class/boundary
                            condition</li>
                        <li>Sufficient tests for statistical significance</li>
                    </ul>

                    <h3>Functional Test Criteria:</h3>
                    <ul>
                        <li>Each functionality must be executed at least
                            once.</li>
                        <li>Test cases use central, border, and special
                            values.</li>
                    </ul>

                    <h3>Equivalence Classes:</h3>
                    <ul>
                        <li>Test cases are grouped into equivalence
                            classes.</li>
                        <li>Failures in a class indicate failures in others
                            within
                            the same class.</li>
                    </ul>

                    <h3>Test Case Selection:</h3>
                    <ul>
                        <li>Every equivalence class must have at least one test
                            case.</li>
                        <li>Test for invalid inputs and cover as many valid
                            cases as
                            possible.</li>
                    </ul>

                    <h3>Limit Conditions:</h3>
                    <ul>
                        <li>Test cases at boundaries often succeed.</li>
                        <li>Include boundaries and values immediately above or
                            below.</li>
                    </ul>

                    <h3>Example - Black Box:</h3>
                    <p><code>abs(x) := (x >= 0 then y = x else y =
                            -x)</code></p>
                    <ul>
                        <li>Equivalence classes: positive and negative
                            <code>x</code></li>
                        <li>Boundary condition: <code>x</code> close to
                            zero.</li>
                    </ul>
                </div>
                <div class="chapter" id="junit">
                    <h2>JUnit: Java Unit Testing Framework</h2>
                    <p>JUnit is a framework designed to assist programmers in
                        defining and executing tests, formalizing requirements,
                        writing/debugging code, and integrating code
                        seamlessly.</p>
                    <p>For each test, JUnit follows these steps:</p>
                    <ul>
                        <li><strong>Pre-test fixtures:</strong> Acquire
                            resources
                            and create objects.</li>
                        <li><strong>Test method:</strong> Check the output of
                            the
                            element under test using assert() methods.</li>
                        <li><strong>Post-test fixtures:</strong> Release
                            resources
                            and remove objects.</li>
                    </ul>
                    <p>Assert methods provided by JUnit include:</p>
                    <ul>
                        <li>assertTrue(boolean test)</li>
                        <li>assertFalse(boolean test)</li>
                        <li>assertEquals(expected, actual)</li>
                        <li>assertSame(Object expected, Object actual)</li>
                        <li>assertNotSame(Object expected, Object actual)</li>
                        <li>assertNull(Object object)</li>
                        <li>assertNotNull(Object object)</li>
                        <li>fail()</li>
                    </ul>
                    <p>JUnit 4 introduced the use of Java annotations and
                        enhanced
                        assert() methods. It executes all methods annotated with
                        "@Test", public, returning void, and with no
                        arguments.</p>
                    <p>Annotations such as @Before and @After are used to
                        designate
                        pre-test and post-test fixtures respectively, to acquire
                        and
                        release resources.</p>
                    <p>Test suites in JUnit require annotations like
                        @RunWith(Suite.class) and @Suite.SuiteClasses({ ... })
                        to
                        execute multiple test classes.</p>
                    <h3>Test Coverage and Effectiveness Metrics</h3>
                    <p><strong>Statement Coverage:</strong> Measures the
                        percentage
                        of statements covered by tests compared to the total
                        number
                        of statements.</p>
                    <p><strong>Test Effectiveness Ratio:</strong> Evaluates the
                        quality of a test case by calculating the ratio of
                        activated
                        elements to the total elements in the test item.</p>
                    <p><strong>Node Coverage:</strong> Ensures that every node
                        in
                        the control flow graph is visited by tests.</p>
                    <p><strong>Edge (Branch) Coverage:</strong> Guarantees that
                        every edge in the control flow graph is traversed by
                        tests.</p>
                    <p><strong>Condition Coverage:</strong> Requires both true
                        and
                        false cases of each boolean condition to be activated by
                        tests.</p>
                    <p><strong>Multiple Condition Coverage:</strong> Demands
                        activation of all possible combinations of
                        conditions.</p>
                    <p><strong>Path Coverage:</strong> Ensures that every path
                        in
                        the control flow graph is executed by tests.</p>
                    <p><strong>Loop Coverage:</strong> Requires three test
                        cases:
                        Not entering the loop, One iteration, More than one
                        iteration.</p>
                </div>
                <div class="chapter" id="testing_process">
                    <h2>Integration and System Testing</h2>
                    <p>Integration and System Testing are applied to an
                        aggregation
                        of two or more units/modules to find faults concerning
                        the
                        interoperation of units and the aggregate whole
                        functions.</p>
                    <ul>
                        <li><strong>Driver:</strong> A unit program or module
                            that
                            invokes the component or module being tested. The
                            driver
                            acts as a substitute for the missing
                            components.</li>
                        <li><strong>Stub:</strong> A simplified implementation
                            of a
                            unit developed to substitute a not yet available
                            unit.</li>
                    </ul>
                    <h3>Testing Strategies</h3>
                    <ul>
                        <li><strong>Top-down testing:</strong> Allows early
                            detection of architectural flaws and requires the
                            definition of stubs for lower-level units.</li>
                        <li><strong>Bottom-up testing:</strong> Testing can
                            start
                            early, lower levels are directly observable, and it
                            requires the definition of drivers for lower-level
                            units.</li>
                    </ul>
                    <h3>Testing Process</h3>
                    <ul>
                        <li><strong>Production testing:</strong> Test products
                            as
                            they are made.</li>
                        <li><strong>Regression testing:</strong> Repeat tests
                            after
                            any change.</li>
                        <li><strong>Acceptance testing:</strong> Data and test
                            cases
                            provided by the customer.</li>
                        <li><strong>Beta-testing:</strong> Conducted with a
                            selected
                            group of potential customers.</li>
                    </ul>
                    <h3>Planning and Specification Documents</h3>
                    <ul>
                        <li><strong>TP (Test Plan):</strong> Establish a plan
                            and
                            schedule, define required resources, define
                            pass/fail
                            criteria, and explain each test.</li>
                        <li><strong>TDS (Test Design Specification):</strong>
                            Outlines techniques, analysis of results,
                            motivation,
                            and generic attributes.</li>
                        <li><strong>TCS (Test Case Specification):</strong>
                            Specifies a test case in terms of input data,
                            expected
                            output, and test conditions (required hardware and
                            software).</li>
                        <li><strong>TPS (Test Procedure Specification):</strong>
                            Details how to execute test cases.</li>
                    </ul>
                    <h3>Execution Deliverables</h3>
                    <ul>
                        <li>Test item report</li>
                        <li>Test log</li>
                        <li>Incident report</li>
                        <li>Summary report</li>
                    </ul>
                    <h3>Test-Driven Development (TDD)</h3>
                    <p>In TDD, test cases are written before the implementation
                        code.</p>
                    <h3>Benefits of TDD</h3>
                    <ul>
                        <li>Code coverage</li>
                        <li>Regression testing</li>
                        <li>Simplified debugging</li>
                        <li>System documentation</li>
                    </ul>
                    <img src="img/testin_process.png"
                        alt="Testing process"
                        style="max-width: 100%; height: auto;">
                </div>
                <div class="chapter" id="junit5">
                    <h2>JUnit 5</h2>
                    <p>JUnit 5 introduces several new features and improvements
                        over
                        previous versions. Key highlights include:</p>
                    <ul>
                        <li><strong>@BeforeEach/@AfterEach</strong>,
                            <strong>@BeforeAll/@AfterAll</strong></li>
                        <li>Test methods are not required to be public</li>
                        <li>Java 8 support (lambda expressions, extensions,
                            parameterized tests, etc.)</li>
                    </ul>
                    <p>Suites:</p>
                    <ul>
                        <li><strong>@RunWith(JUnitPlatform.class)</strong></li>
                        <li><strong>@SelectClasses({ … })</strong></li>
                        <li><strong>@SelectPackages({ … })</strong></li>
                    </ul>
                    <img src="img/exception_test.png"
                        alt="Exception test"
                        style="max-width: 100%; height: auto;">
                    <h3>Assertion Styles:</h3>
                    <p><strong>Hamcrest Matchers:</strong> Use
                        <code>assertThat(value, matcher)</code></p>
                    <ul>
                        <li>Matchers:</li>
                        <ul>
                            <li><code>equalTo()</code>,
                                <code>instanceOf()</code>,
                                <code>notNullValue()</code>,
                                <code>nullValue()</code>,
                                <code>sameInstance()</code></li>
                            <li>Numbers: <code>closeTo()</code>,
                                <code>greaterThan()</code>,
                                <code>greaterThanOrEqualTo()</code>,
                                <code>lessThan()</code>,
                                <code>lessThanOrEqualTo()</code></li>
                            <li>Logical: <code>allOf()</code>,
                                <code>anyOf()</code>,
                                <code>not()</code></li>
                            <li>String: <code>equalToIgnoringCase()</code>,
                                <code>equalToIgnoringWhiteSpace()</code>,
                                <code>containsString()</code>,
                                <code>endsWith()</code>,
                                <code>startsWith()</code></li>
                            <li>Collections: <code>array()</code>,
                                <code>hasItemInArray()</code>,
                                <code>hasItem()</code>, <code>hasItems()</code>,
                                <code>hasEntry()</code>, <code>hasKey()</code>,
                                <code>hasValue()</code> (for
                                <code>Map</code>)</li>
                        </ul>
                    </ul>

                    <p><strong>AssertJ Fluent Assertions:</strong> Provides a
                        single
                        <code>assertThat(actual)</code> method, which returns an
                        Assert object. The method <code>as()</code> can be used
                        to
                        define a message.</p>
                    <p>Example:
                        <code>assertThat(res).as("Checking return value").isNotNull().isEqualTo(expected);</code></p>
                    <ul>
                        <li>Object Assertions:</li>
                        <ul>
                            <li><code>isEqualTo()</code>,
                                <code>isInstanceOf()</code>,
                                <code>isNotNull()</code>, <code>isNull()</code>,
                                <code>isSameAs()</code>, <code>returns()</code>,
                                <code>hasFieldOrPropertyWithValue()</code>,
                                <code>extracting()</code></li>
                        </ul>
                        <li>Number Assertions:</li>
                        <ul>
                            <li><code>isCloseTo()</code>,
                                <code>isGreaterThan()</code>,
                                <code>isGreaterThanOrEqualTo()</code>,
                                <code>isLessThan()</code>,
                                <code>isLessThanOrEqualTo()</code>,
                                <code>isBetween()</code></li>
                        </ul>
                        <li>String Assertions:</li>
                        <ul>
                            <li><code>startsWith()</code>,
                                <code>endsWith()</code>,
                                <code>contains()</code>,
                                <code>doesNotContain()</code>,
                                <code>isEqualToIgnoringCase()</code></li>
                        </ul>
                        <li>Container Assertions:</li>
                        <ul>
                            <li><code>hasSize()</code>,
                                <code>hasSizeLessThan()</code>,
                                <code>hasSizeGreaterThan()</code>,
                                <code>isSorted()</code>,
                                <code>contains()</code>,
                                <code>containsExactly()</code>,
                                <code>extracting()</code>,
                                <code>filteredOn()</code></li>
                        </ul>
                        <li>Map Assertions:</li>
                        <ul>
                            <li><code>containsKeys()</code>,
                                <code>containsEntry()</code>,
                                <code>contains()</code>, <code>entry()</code>,
                                <code>extractingFromEntries()</code></li>
                        </ul>
                        <li>Exception Assertions:</li>
                        <ul>
                            <li><code>assertThatThrownBy()</code>,
                                <code>hasMessage()</code></li>
                        </ul>
                    </ul>
                </div>
                <div class="chapter" id="advancedTesting">
                    <h2>Software Testing – Advanced Topics</h2>
                    <h3>Dynamic Analysis</h3>
                    <p><strong>Property-Based Testing:</strong> Derive automatic
                        test cases using Jqwik for Java. Jqwik is able to
                        generate
                        objects of most Java types.</p>
                    <ul>
                        <li><code>@Property</code> defines the method running
                            the
                            PBT</li>
                        <li><code>@ForAll</code> generates random values for the
                            enclosed variable</li>
                    </ul>
                    <p>Example: <code>Arbitraries.integers().between(1,
                            300).filter(anInt -> anInt % 6 == 0)</code></p>
                    <p>Patterns for finding properties include:</p>
                    <ul>
                        <li>Business rule as property</li>
                        <li>Inverse, Idempotent, Invariant functions,
                            Commutativity</li>
                        <li>Test oracle</li>
                        <li>Hard to compute, but easy to verify</li>
                        <li>Induction</li>
                        <li>Stateful testing</li>
                        <li>Fuzzing</li>
                    </ul>
                    <p><strong>Mutation Testing:</strong> A mutant is a copy of
                        the
                        original program with a small artificial change. Its
                        behaviors and outputs differ from those of the original.
                        If
                        your tests fail, the mutation is killed; if your tests
                        pass,
                        the mutation survived. PITest runs your unit tests
                        against
                        automatically modified versions of your code.</p>

                    <h3>Static Analysis</h3>
                    <p><strong>Compilation analysis:</strong> Compilers check
                        for
                        syntax, types, and semantic correctness.</p>
                    <p><strong>Data Flow Analysis:</strong> Analyzes the values
                        of
                        variables during execution. Three operations on
                        variables:
                        definition, use, nullification.</p>
                    <p><strong>Symbolic Execution:</strong></p>
                    <ul>
                        <li><strong>Static:</strong> The program is executed
                            with
                            symbolic values instead of actual values. Determine
                            all
                            the path conditions (path constraints) by
                            propagating
                            symbolic input values along the path.</li>
                        <li><strong>Dynamic:</strong> A random test case
                            collects
                            symbolic constraints along the executed path,
                            negates
                            the branch condition in the path, and generates a
                            new
                            test input for the negated constraint.</li>
                    </ul>
                    <p><strong>Inspections:</strong> Reading documents/code to
                        find
                        defects.</p>

                    <h3>Performance Testing:</h3>
                    <p>Non-functional testing, where the performance of the
                        application is evaluated under expected or higher
                        load.</p>
                    <ul>
                        <li><strong>Throughput:</strong> Number of requests
                            processed in a specified time duration.</li>
                        <li><strong>Response Time:</strong> Time taken to
                            complete
                            each transaction.</li>
                        <li>Memory/network, CPU usage</li>
                    </ul>
                    <p><strong>Tuning:</strong> Product performance is enhanced
                        by
                        setting different values to the parameters without
                        touching
                        source code.</p>
                    <p><strong>Benchmarking:</strong> Comparison across
                        competitive
                        products.</p>
                    <p><strong>Load Testing:</strong> Increasing the load on the
                        system.</p>
                    <p><strong>Stress Testing:</strong> Overwhelming resources
                        or
                        removing resources to ensure the system fails and
                        recovers.</p>
                    <p><strong>Spike Testing:</strong> Increasing the load
                        abruptly,
                        then measuring performance at the peak and at zero
                        load.</p>
                    <p><strong>Endurance Testing:</strong> Testing performance
                        under
                        certain load conditions over an extended period.</p>
                    <p><strong>Volume Testing:</strong> Testing with huge
                        amounts of
                        data and analyzing response time.</p>
                    <p><strong>Scalability Testing:</strong> Testing the ability
                        of
                        software to scale up with increasing workload and data
                        traffic.</p>
                    <ul>
                        <li><strong>Upward Scalability Testing:</strong>
                            Expanding
                            the number of users until a crash point.</li>
                        <li><strong>Downward Scalability Testing:</strong> When
                            load
                            testing fails, decreasing the number of users.</li>
                    </ul>
                    <p><strong>Apache JMeter:</strong> Load testing functional
                        behavior and measuring performance.</p>
                </div>
                <div class="chapter" id="agile">
                    <h2>Agile Methodologies</h2>
                    <h3>Waterfall Method</h3>
                    <p>The Waterfall methodology is plan-driven and is suitable
                        for
                        large projects with well-understood and stable
                        requirements.
                        It involves limited changes and is less responsive to
                        changing needs.</p>

                    <h3>Incremental Development</h3>
                    <p>Incremental development involves developing the software
                        in
                        stages: initial, intermediate, and final versions. This
                        approach reduces the cost of changes, allows customer
                        interaction, and supports rapid delivery. However, it
                        has
                        some disadvantages:</p>
                    <ul>
                        <li>Not a visible process</li>
                        <li>Structure tends to degrade over time</li>
                        <li>Frequent refactoring is needed</li>
                    </ul>

                    <h3>Incremental Delivery</h3>
                    <p>Incremental delivery involves deploying increments for
                        end-users, allowing for a more realistic evaluation of
                        the
                        software. However, it can be difficult to apply in
                        replacement systems.</p>

                    <h3>Integration and Configuration</h3>
                    <p>This approach emphasizes software reuse and integration
                        from
                        existing components.</p>

                    <h3>Agile Methods</h3>
                    <p>Agile methodologies focus on the rapid delivery of
                        software,
                        minimizing documentation, and emphasizing the code to
                        avoid
                        software failure and reduce overheads. Key principles of
                        Agile methods include:</p>
                    <ul>
                        <li>Customer involvement</li>
                        <li>Incremental delivery</li>
                        <li>People over processes</li>
                        <li>Embrace changes</li>
                        <li>Maintain simplicity</li>
                    </ul>

                    <h3>Extreme Programming (XP)</h3>
                    <p>Extreme Programming (XP) is an Agile method that
                        emphasizes
                        the rapid development and delivery of software. Key
                        practices of XP include:</p>
                    <ul>
                        <li>Releasing new versions several times a day</li>
                        <li>Delivering increments every two weeks</li>
                        <li>Running tests for every build</li>
                        <li>Constant code refactoring</li>
                        <li>Using user stories for requirements</li>
                        <li>Pair programming (two developers working together on
                            the
                            same code)</li>
                    </ul>
                </div>
                <div class="chapter" id="scrum">
                    <h2>SCRUM</h2>
                    <p>SCRUM is an agile method that focuses on managing
                        iterative
                        development. It consists of three phases:</p>
                    <ol>
                        <li>Outline planning: Involves defining objectives and
                            software architecture.</li>
                        <li>Series of sprint cycles.</li>
                        <li>Closure phase: Wraps up the project, including
                            documentation.</li>
                    </ol>
                    <p>Benefits of SCRUM include breaking the product down into
                        understandable chunks and allowing the customer to see
                        one-time delivery of increments.</p>
                    <p>The Product Owner controls the Product Backlog.</p>
                    <img src="img/scrum.png"
                        alt="Verification and Validation Techniques"
                        style="max-width: 100%; height: auto;">
                    <h3>Roles:</h3>
                    <ul>
                        <li><strong>Product Owner:</strong> Controls the
                            priority of
                            the team's backlog, working closely with
                            stakeholders.</li>
                        <li><strong>Scrum Master:</strong> Their goal is to
                            produce
                            a self-organizing team.</li>
                        <li><strong>Team member:</strong> Each member is
                            self-organizing.</li>
                    </ul>
                    <p>The <strong>Product Backlog</strong> is responsible for
                        the
                        ordering of stories (description of desired
                        functionality)
                        and any changes. It is the property of the Product
                        Owner.</p>
                    <p>The <strong>Sprint Backlog</strong> consists of committed
                        stories and additional tasks. It is the property of the
                        team.</p>
                </div>
                <div class="chapter" id="devops">
                    <h2>DevOps</h2>
                    <p>DevOps provides automation to enable efficient collection
                        and
                        organization of data and communication of the data to
                        appropriate actors without human intervention. Key
                        aspects
                        of DevOps include:</p>
                    <ul>
                        <li>Alignment of development and operations teams
                            towards
                            the same goal.</li>
                        <li>Focus on faster collaboration, often seeking
                            automation
                            wherever possible.</li>
                        <li>Utilization of automation to handle deployment
                            processes.</li>
                        <li>Integration of reusable tools and components to
                            streamline workflows.</li>
                        <li>Encouragement of collaboration across disciplines
                            within
                            the organization.</li>
                        <li>Development and testing against a production-like
                            system
                            environment.</li>
                        <li>Adoption of iterative and frequent deployments using
                            repeatable and reliable processes.</li>
                        <li>Continuous validation of operational quality
                            characteristics.</li>
                        <li>Emphasis on increasing feedback loops to improve
                            efficiency and effectiveness.</li>
                    </ul>
                </div>
                <div class="chapter" id="continuous-deployment">
                    <h2>Continuous Deployment</h2>
                    <p>Continuous Deployment involves building pipelines that
                        streamline the entire engineering organization, from
                        development to QA to operations. Key features of
                        continuous
                        deployment include:</p>
                    <ul>
                        <li>Implementation of pipelines to automate and optimize
                            the
                            flow of code from development through testing to
                            production deployment.</li>
                        <li>Integration of automated testing and quality
                            assurance
                            processes into the deployment pipeline.</li>
                        <li>Emphasis on fast and reliable deployments, often
                            with
                            minimal human intervention.</li>
                        <li>Continuous monitoring and feedback loops to identify
                            and
                            address issues promptly.</li>
                        <li>Focus on scalability and resilience to ensure the
                            stability of deployed systems.</li>
                    </ul>
                </div>
                <div class="chapter" id="aspectOriented">
                    <h2>Aspect Oriented Programming</h2>
                    <p>Aspect Oriented Programming (AOP) provides the key
                        advantage
                        of separation of concerns, where each program element
                        does
                        only one thing.</p>
                    <ul>
                        <li><strong>Scattered code:</strong> Related code is not
                            local; the implementation of a concern is scattered
                            across several components.</li>
                        <li><strong>Tangled code:</strong> A module includes
                            code
                            that implements different requirements, making it
                            difficult to understand and change.</li>
                        <li><strong>Redundant code:</strong> The same fragment
                            of
                            code appears in many places.</li>
                    </ul>
                    <p><strong>Concerns:</strong></p>
                    <ul>
                        <li><strong>Core concerns:</strong> Functional concerns
                            related to the primary purpose of a system.</li>
                        <li><strong>Secondary concerns:</strong> Functional
                            concerns
                            that reflect non-functional and QoS (Quality of
                            Service)
                            requirements.</li>
                    </ul>
                    <p><strong>Stakeholder concerns:</strong></p>
                    <ul>
                        <li>Related to specific functionality</li>
                        <li>QoS</li>
                        <li>Policy concerns</li>
                        <li>System concerns: maintainability and
                            configurability</li>
                        <li>Organisational concerns: budget, assets,
                            repudiation</li>
                    </ul>
                    <p><strong>Cross-cutting concerns:</strong> These are
                        concerns
                        whose implementation cuts across multiple components,
                        leading to tangling and scattering. Examples
                        include:</p>
                    <ul>
                        <li>Logging</li>
                        <li>Debugging</li>
                        <li>Profiling (Performance)</li>
                        <li>Security & Authentication</li>
                        <li>Exception Handling</li>
                        <li>Event Handling</li>
                        <li>Synchronization</li>
                        <li>Session tracking and expiration</li>
                        <li>Database connection & Persistence</li>
                    </ul>
                    <p>By representing cross-cutting concerns as aspects,
                        individual
                        concerns can be understood, reused, and modified without
                        changing other parts of the program.</p>
                    <img src="img/aspect.png"
                        alt="Verification and Validation Techniques"
                        style="max-width: 100%; height: auto;">
                    <p><strong>Obliviousness:</strong> Implicit invocation of an
                        aspect.</p>
                    <p><strong>Benefits of AOP:</strong></p>
                    <ul>
                        <li>Better modularity: Localizes cross-cutting concerns
                            in
                            an aspect.</li>
                        <li>Easier understanding: Less scattered and tangled
                            code.</li>
                        <li>Easier modifiability.</li>
                    </ul>
                    <p><strong>Advice declarations:</strong></p>
                    <ul>
                        <li><strong>Before advice:</strong> Runs when the join
                            point
                            is reached, before the method runs.</li>
                        <ul>
                            <li>Before call / Before execution</li>
                        </ul>
                        <li><strong>After advice:</strong> Runs just after the
                            method.</li>
                        <ul>
                            <li>After returning: After the method ends
                                normally.</li>
                            <li>After throwing: After the method ends by
                                throwing an
                                exception.</li>
                            <li>After: Runs after both previous cases.</li>
                        </ul>
                        <li><strong>Around advice:</strong> Runs when the join
                            point
                            is reached and has control over whether the method
                            itself runs at all. It surrounds the join point, can
                            decide if computation will happen, and can modify
                            arguments.</li>
                    </ul>
                    <p><strong>ThisJoinPoint:</strong> A feature providing
                        details
                        of the join point, such as the source location, string
                        representation of the current join point, arguments of
                        the
                        method, target object, etc.</p>
                </div>
                <div class="chapter" id="springAOP">
                    <h2>Spring AOP</h2>
                    <p>Spring AOP (Aspect-Oriented Programming) is a framework
                        that
                        provides an additional way of modularizing cross-cutting
                        concerns by separating them from the business logic.</p>
                    <ul>
                        <li><strong>Aspect:</strong> An aspect is a module of
                            cross-cutting concerns. It encapsulates behaviors
                            that
                            affect multiple classes or modules in your
                            application.</li>
                        <li><strong>Advice:</strong> Advice is the action taken
                            by
                            an aspect at a particular join point. Different
                            types of
                            advice include "before," "after," "around,"
                            "after-returning," and "after-throwing."</li>
                        <li><strong>Join Point:</strong> A point during the
                            execution of a program where an aspect can be
                            plugged
                            in. In Spring AOP, join points are method
                            invocations.</li>
                        <li><strong>Pointcut:</strong> A pointcut is a set of
                            one or
                            more join points where advice should be executed. It
                            defines where an aspect should be applied in your
                            application.</li>
                        <li><strong>Introduction:</strong> Introduction allows
                            adding new methods or attributes to existing
                            classes.
                            This helps in keeping the core concerns separated
                            from
                            cross-cutting concerns.</li>
                        <li><strong>Weaving:</strong> Weaving is the process of
                            integrating aspects into the application code. This
                            can
                            be done at compile time, load time, or runtime.</li>
                        <li><strong>Proxy-based:</strong> Spring AOP uses
                            runtime
                            proxies to apply aspects to the target objects. This
                            means that the AOP functionality is applied at
                            runtime
                            and does not require altering the original
                            class.</li>
                        <li><strong>Configuration:</strong> Aspects in Spring
                            AOP
                            can be configured either using XML-based
                            configuration
                            or annotation-based configuration.</li>
                        <li><strong>AspectJ integration:</strong> Spring allows
                            you
                            to use AspectJ annotations and expressions for more
                            advanced AOP configurations.</li>
                    </ul>
                </div>
                <div class="chapter" id="prolog">
                    <h2>Prolog</h2>
                    <p>Prolog (PROgramming in LOGic) allows the computer to
                        solve
                        problems using principles of logic. It is a declarative
                        language, consisting of declarations (statements or
                        propositions in symbolic logic).</p>
                    <p>Key concepts in Prolog include:</p>
                    <ul>
                        <li><strong>Horn clauses:</strong> If (BODY) then
                            HEAD</li>
                        <li><strong>Propositions:</strong> Logical statements,
                            e.g.,
                            <code>likes(john, football)</code></li>
                        <li><strong>Logical connectors:</strong> Negation,
                            conjunction, disjunction, equivalence,
                            implication</li>
                        <li><strong>Quantifiers:</strong> For all, exists</li>
                    </ul>
                    <p><strong>Resolution:</strong> If the head of horn clause
                        #1
                        matches one of the terms in horn clause #2, then we can
                        replace that term with the body of clause #1.</p>
                    <p><strong>Unification:</strong> Finding values for
                        variables
                        during resolution so that the matching process can
                        succeed.</p>
                    <p><strong>Instantiation:</strong> Temporary binding of a
                        value
                        (and type) to a variable to allow unification.</p>
                    <p>Prolog syntax and terminology:</p>
                    <ul>
                        <li><strong>Constants:</strong> Start with lowercase
                            letters</li>
                        <li><strong>Variables:</strong> Start with uppercase
                            letters</li>
                        <li><strong>Query (goal):</strong> <code>?-
                                rainy(seattle)</code></li>
                        <li><strong>Knowledge Base:</strong> Collection of facts
                            and
                            rules</li>
                        <li><strong>Facts:</strong> Statements assumed to be
                            true,
                            e.g., <code>male(steve)</code></li>
                        <li><strong>Rules:</strong> Predicates that are true
                            depending on a given condition, e.g.,
                            <code>parent(X, Y)
                                :- mother(X, Y)</code></li>
                        <li><strong>Logical connectors:</strong>
                            <code>AND</code>
                            (comma), <code>OR</code> (semi-colon)</li>
                    </ul>
                    <p><strong>Forward chaining:</strong> (bottom-up) starts
                        with
                        each rule and checks the facts. Works more efficiently
                        on a
                        small database.</p>
                    <p><strong>Backward chaining:</strong> (top-down) starts
                        with
                        the facts and uses the rules that apply, using a
                        depth-first
                        resolution process (in sequence). Prolog uses backward
                        chaining.</p>
                    <p>A Knowledge Base of Horn clauses can be represented with
                        an
                        AND-OR graph.</p>
                </div>
            </div>
        </div>
    </div>
    <script>
        window.addEventListener('DOMContentLoaded', function() {
            const chapters = document.querySelectorAll('.chapter');
            const index = document.getElementById('index').querySelector('ul');

            chapters.forEach(chapter => {
                const heading = chapter.querySelector('h2').textContent;
                const listItem = document.createElement('li');
                const anchor = document.createElement('a');

                anchor.href = '#' + chapter.id;
                anchor.textContent = heading;
                listItem.appendChild(anchor);
                index.appendChild(listItem);
            });
        });
    </script>
</body>
</html>
